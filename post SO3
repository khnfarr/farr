Siap — aku bantu **lengkap**: (1) analisis perbedaan FCFS vs SJF, (2) dua program C sederhana (FCFS non-preemptive & SJF non-preemptive) siap compile/run di compiler biasa, (3) contoh input & **hasil running** yang harus kamu dapatkan (supaya bisa screenshot), dan (4) langkah singkat cara compile & capture screenshot.
Semua dibuat singkat, tepat, dan sesuai permintaan post-test.

---

# 1) Inti perbandingan FCFS vs SJF (ringkas & tepat)

**FCFS (First-Come First-Served)**

* Prinsip: proses dijalankan sesuai urutan kedatangan (FIFO).
* Kelebihan: sederhana, adil berdasarkan waktu datang.
* Kekurangan: *convoy effect* — proses panjang dapat menunda banyak proses pendek → rata-rata waiting time besar.
* Starvation: **tidak** terjadi (selama proses selesai).
* Kompleksitas: O(n) menghitung waiting/turnaround setelah urutan diketahui.
* Use case: ketika urutan kedatangan penting atau overhead context switch harus minimal.

**SJF (Shortest Job First) — non-preemptive**

* Prinsip: eksekusi proses dengan burst time terpendek terlebih dahulu.
* Kelebihan: meminimalkan rata-rata waiting time (optimal untuk set proses sudah diketahui burstnya).
* Kekurangan: bisa menyebabkan **starvation** bagi proses berdurasi panjang jika proses pendek terus datang (untuk preemptive juga punya isu); juga memerlukan estimasi burst time.
* Kompleksitas: perlu penyortiran O(n log n) (atau O(n^2) implementasi sederhana).
* Use case: batch system di mana durasi pekerjaan diketahui sebelumnya.

**Perbedaan efek nyata pada metrik**

* FCFS mempertahankan urutan input → rata-rata waiting time sering lebih tinggi.
* SJF mengurangi rata-rata waiting time/turnaround time secara signifikan untuk kumpulan proses yang sama (non-preemptive) karena mengeksekusi proses pendek dulu.

---

# 2) Program C: FCFS (non-preemptive)

Simpan sebagai `fcfs.c`.

```c
#include <stdio.h>

int main() {
    int n, i;
    int bt[50], wt[50], tat[50];
    int total_wt = 0, total_tat = 0;

    printf("Masukkan jumlah proses: ");
    scanf("%d", &n);

    for(i=0;i<n;i++){
        printf("Masukkan Burst Time untuk Proses %d: ", i);
        scanf("%d", &bt[i]);
    }

    wt[0] = 0;
    for(i=1;i<n;i++){
        wt[i] = wt[i-1] + bt[i-1];
    }
    for(i=0;i<n;i++){
        tat[i] = wt[i] + bt[i];
        total_wt += wt[i];
        total_tat += tat[i];
    }

    printf("\nPROCESS\tBURST TIME\tWAITING TIME\tTURNAROUND TIME\n");
    for(i=0;i<n;i++){
        printf("P%d\t%d\t\t%d\t\t%d\n", i, bt[i], wt[i], tat[i]);
    }

    printf("\nRata-rata Waiting Time = %.6f\n", (float)total_wt / n);
    printf("Rata-rata Turnaround Time = %.6f\n", (float)total_tat / n);

    return 0;
}
```

**Contoh input (sama seperti soal di buku slide):**

* n = 3
* Burst times: 24 3 3

**Expected output (copy/paste ini akan muncul saat kamu run):**

```
PROCESS BURST TIME    WAITING TIME    TURNAROUND TIME
P0      24              0               24
P1      3               24              27
P2      3               27              30

Rata-rata Waiting Time = 17.000000
Rata-rata Turnaround Time = 27.000000
```

---

# 3) Program C: SJF non-preemptive

Simpan sebagai `sjf.c`.

```c
#include <stdio.h>

int main() {
    int n, i, j;
    int pid[50], bt[50], wt[50], tat[50];
    int total_wt = 0, total_tat = 0;

    printf("Masukkan jumlah proses: ");
    scanf("%d", &n);

    for(i=0;i<n;i++){
        pid[i] = i;
        printf("Masukkan Burst Time untuk Proses %d: ", i);
        scanf("%d", &bt[i]);
    }

    /* simple selection sort by burst time */
    for(i=0;i<n-1;i++){
        for(j=i+1;j<n;j++){
            if(bt[j] < bt[i]) {
                int tmp;
                tmp = bt[i]; bt[i] = bt[j]; bt[j] = tmp;
                tmp = pid[i]; pid[i] = pid[j]; pid[j] = tmp;
            }
        }
    }

    wt[0] = 0;
    for(i=1;i<n;i++){
        wt[i] = wt[i-1] + bt[i-1];
    }
    for(i=0;i<n;i++){
        tat[i] = wt[i] + bt[i];
        total_wt += wt[i];
        total_tat += tat[i];
    }

    printf("\nPROCESS\tBURST TIME\tWAITING TIME\tTURNAROUND TIME\n");
    for(i=0;i<n;i++){
        printf("P%d\t%d\t\t%d\t\t%d\n", pid[i], bt[i], wt[i], tat[i]);
    }

    printf("\nRata-rata Waiting Time = %.6f\n", (float)total_wt / n);
    printf("Rata-rata Turnaround Time = %.6f\n", (float)total_tat / n);

    return 0;
}
```

**Contoh input (sama data):**

* n = 3
* Burst times: 24 3 3

**Expected output (SJF akan urutkan proses berdasar burst):**

```
PROCESS BURST TIME    WAITING TIME    TURNAROUND TIME
P1      3               0               3
P2      3               3               6
P0      24              6               30

Rata-rata Waiting Time = 3.000000
Rata-rata Turnaround Time = 13.000000
```

> Catatan: Program SJF di atas menampilkan `pid` asli proses setelah di-sort sehingga kamu bisa lihat perubahan urutan.

---

# 4) Cara compile & run (Dev C++ / GCC / Code::Blocks)

1. Simpan file `fcfs.c` dan `sjf.c`.
2. Compile (GCC):

   * `gcc fcfs.c -o fcfs`
   * `gcc sjf.c -o sjf`
     (Atau gunakan compile/run di Dev C++ sama cara.)
3. Jalankan program: `./fcfs` lalu masukkan input contoh; ambil screenshot terminal yang menampilkan output.
   Lakukan juga untuk `./sjf`.

---

# 5) Tips untuk screenshot hasil running (agar nilai sempurna)

* Tampilkan **input** yang kamu masukkan dan **output** terminal yang lengkap (lihat contoh di atas).
* Screenshot harus jelas memperlihatkan: nama file/console, perintah compile (opsional), dan output program.
* Jika diminta upload ke LMS, simpan screenshot sebagai PNG/JPG dengan resolusi jelas.

---

# 6) Ringkasan jawaban post-test yang bisa kamu masukkan

1. **Analisis perbedaan** (pakai paragraf singkat yang aku tulis di bagian 1).
2. **Lampirkan screenshot**: menjalankan `fcfs.c` dengan input `3` & `24 3 3` → hasil seperti contoh FCFS; dan menjalankan `sjf.c` dengan input yang sama → hasil seperti contoh SJF.
3. (Opsional) Cantumkan kode sumber (fcfs.c & sjf.c) sebagai lampiran atau di appendix.

---

